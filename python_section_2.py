# -*- coding: utf-8 -*-
"""python_section_2.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k7xkV1GijIax5u6iMKyVqYJRS-Q8OpND

Q9: Create a function named calculate_distance_matrix that takes the dataset-2.csv as input and generates a DataFrame representing distances between IDs.

The resulting DataFrame should have cumulative distances along known routes, with diagonal values set to 0. If distances between toll locations A to B and B to C are known, then the distance from A to C should be the sum of these distances. Ensure the matrix is symmetric, accounting for bidirectional distances between toll locations (i.e. A to B is equal to B to A).
"""

import pandas as pd
import numpy as np
file_path =  "/content/dataset-2.csv"

import pandas as pd
import numpy as np

def calculate_distance_matrix(file_path):
    data = pd.read_csv("/content/dataset-2.csv", dtype={'id_start': int, 'id_end': int, 'distance': float})
    unique_ids = pd.unique(data[['id_start', 'id_end']].values.ravel())
    distance_matrix = pd.DataFrame(np.nan, index=unique_ids, columns=unique_ids)
    for _, row in data.iterrows():
        id_start, id_end, dist = row['id_start'], row['id_end'], row['distance']
        distance_matrix.loc[id_start, id_end] = dist
        distance_matrix.loc[id_end, id_start] = dist
    np.fill_diagonal(distance_matrix.values, 0)
    for k in unique_ids:
        for i in unique_ids:
            for j in unique_ids:
                if pd.isna(distance_matrix.loc[i, j]):
                    if not pd.isna(distance_matrix.loc[i, k]) and not pd.isna(distance_matrix.loc[k, j]):
                        distance_matrix.loc[i, j] = distance_matrix.loc[i, k] + distance_matrix.loc[k, j]
                        distance_matrix.loc[j, i] = distance_matrix.loc[i, j]  # Ensure symmetry

    distance_matrix.fillna('inf', inplace=True)
    return distance_matrix

distance_matrix = calculate_distance_matrix(file_path)
print(distance_matrix)

"""Q10:Create a function unroll_distance_matrix that takes the DataFrame created in Question 9. The resulting DataFrame should have three columns: columns id_start, id_end, and distance.

All the combinations except for same id_start to id_end must be present in the rows with their distance values from the input DataFrame.
"""

def unroll_distance_matrix(distance_matrix):
    unrolled_df = distance_matrix.reset_index().melt(id_vars='index', var_name='id_end', value_name='distance')
    unrolled_df.rename(columns={'index': 'id_start'}, inplace=True)
    unrolled_df = unrolled_df[unrolled_df['id_start'] != unrolled_df['id_end']]
    return unrolled_df

unrolled_df = unroll_distance_matrix(distance_matrix)
print(unrolled_df)

"""Q11:Create a function find_ids_within_ten_percentage_threshold that takes the DataFrame created in Question 10 and a reference value from the id_start column as an integer.

Calculate average distance for the reference value given as an input and return a sorted list of values from id_start column which lie within 10% (including ceiling and floor) of the reference value's average.
"""

def find_ids_within_ten_percentage_threshold(unrolled_df, reference_value):
    reference_rows = unrolled_df[unrolled_df['id_start'] == reference_value]
    avg_distance = reference_rows['distance'].mean()
    lower_bound = avg_distance * 0.9
    upper_bound = avg_distance * 1.1
    avg_distances = unrolled_df.groupby('id_start')['distance'].mean().reset_index()
    ids_within_threshold = avg_distances[(avg_distances['distance'] >= lower_bound) & (avg_distances['distance'] <= upper_bound)]['id_start'].tolist()
    ids_within_threshold.sort()
    return ids_within_threshold

reference_value = 1
ids_within_threshold = find_ids_within_ten_percentage_threshold(unrolled_df, reference_value)
print(ids_within_threshold)

"""Q12: Create a function calculate_toll_rate that takes the DataFrame created in Question 10 as input and calculates toll rates based on vehicle types.

The resulting DataFrame should add 5 columns to the input DataFrame: moto, car, rv, bus, and truck with their respective rate coefficients. The toll rates should be calculated by multiplying the distance with the given rate coefficients for each vehicle type:

0.8 for moto
1.2 for car
1.5 for rv
2.2 for bus
3.6 for truck
"""

def calculate_toll_rate(unrolled_df):
    rate_coefficients = {'moto': 0.8,'car': 1.2,'rv': 1.5,'bus': 2.2,'truck': 3.6}
    for vehicle, rate in rate_coefficients.items():
        unrolled_df[vehicle] = unrolled_df['distance'] * rate
    return unrolled_df

toll_rate_df = calculate_toll_rate(unrolled_df)
print(toll_rate_df)

"""Q13:Create a function named calculate_time_based_toll_rates that takes the DataFrame created in Question 12 as input and calculates toll rates for different time intervals within a day.

The resulting DataFrame should have these five columns added to the input: start_day, start_time, end_day, and end_time.

start_day, end_day must be strings with day values (from Monday to Sunday in proper case)
start_time and end_time must be of type datetime.time() with the values from time range given below.
Modify the values of vehicle columns according to the following time ranges:

Weekdays (Monday - Friday):

From 00:00:00 to 10:00:00: Apply a discount factor of 0.8
From 10:00:00 to 18:00:00: Apply a discount factor of 1.2
From 18:00:00 to 23:59:59: Apply a discount factor of 0.8
Weekends (Saturday and Sunday):

Apply a constant discount factor of 0.7 for all times.
For each unique (id_start, id_end) pair, cover a full 24-hour period (from 12:00:00 AM to 11:59:59 PM) and span all 7 days of the week (from Monday to Sunday).
"""

import pandas as pd
from datetime import time

def calculate_time_based_toll_rates(toll_rate_df):
    days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
    time_intervals = [(time(0, 0, 0), time(10, 0, 0)),(time(10, 0, 0), time(18, 0, 0)),(time(18, 0, 0), time(23, 59, 59))]
    toll_rate_rows = []
    for index, row in toll_rate_df.iterrows():
        for day in days_of_week:
            for start_time, end_time in time_intervals:
                if day in ['Saturday', 'Sunday']:
                    discount_factor = 0.7
                else:
                    if start_time == time(0, 0, 0):
                        discount_factor = 0.8
                    elif start_time == time(10, 0, 0):
                        discount_factor = 1.2
                    else:
                        discount_factor = 0.8

                moto_rate = row['moto'] * discount_factor
                car_rate = row['car'] * discount_factor
                rv_rate = row['rv'] * discount_factor
                bus_rate = row['bus'] * discount_factor
                truck_rate = row['truck'] * discount_factor

                toll_rate_rows.append({'id_start': row['id_start'],'id_end': row['id_end'],'distance': row['distance'],'start_day': day,'start_time': start_time,'end_day': day,'end_time': end_time,'moto': moto_rate,'car': car_rate,'rv': rv_rate,'bus': bus_rate,'truck': truck_rate})
    time_based_toll_df = pd.DataFrame(toll_rate_rows)
    return time_based_toll_df

time_based_toll_df = calculate_time_based_toll_rates(toll_rate_df)
print(time_based_toll_df)